package online.colaba

import org.gradle.api.GradleException
import org.gradle.api.Project
import org.gradle.api.tasks.Input
import org.gradle.api.tasks.TaskAction
import org.gradle.api.tasks.TaskProvider
import org.gradle.kotlin.dsl.named
import org.gradle.kotlin.dsl.register
import java.io.File

open class OpenApiAxiosTypeScriptCodeGenerator : Executor() {
    init {
        group = "$dockerPrefix-${project.name}"
        description = "Generating [ TypeScript Axios API] OPEN API."
    }

    @get:Input var fromLocation : String = "/src/test/resources"
    @get:Input var fromFilename : String = "openapi.json"

    @get:Input var toFolder   : String = "/frontend/api/${project.name}"
    @get:Input var toFilename : String = "schema-${project.name}"

    @get:Input var generatorName : String  = "typescript-axios"

    @get:Input var addInfo : Set<String> = setOf(
        "swaggerAnnotations=true",
        "supportsES6=true",
        "serviceImplementation=true",
        "nullSafeAdditionalProps=true",
        "enumPropertyNaming=UPPERCASE",
        "typescriptThreePlus=true",
        "legacyDiscriminatorBehavior=false",
    )
    @get:Input var deleteNotTSFiles : Boolean = true

    @get:Input var separateModels : Boolean = true
    @get:Input var apiPackage     : String  = "controllers"
    @get:Input var modelPackage   : String  = "models"

    @get:Input var enablePostProcessFile : Boolean = false
    @get:Input var mapSetsToArrays : Boolean = true


    @TaskAction override fun exec() {
        var arguments = addInfo.joinToString(",")
        if (separateModels) arguments += ",withSeparateModelsAndApi=true,modelPackage=$modelPackage,apiPackage=$apiPackage"
        if (enablePostProcessFile) arguments += ",enablePostProcessFile=true"

        val from = File("${project.projectDir}$fromLocation/$fromFilename")
        val to = File("${project.rootDir}/$toFolder")

        if (from.exists()) {
            printStartHeader()

            val generator = "--generator-name $generatorName"
            val mappings = if (mapSetsToArrays) "--type-mappings set=Array" else ""
            val additional = "--additional-properties=$arguments"

            val cliPath: String = ProcessBuilder("/bin/bash", "-l", "-c", "which openapi-generator-cli")
                .redirectOutput(ProcessBuilder.Redirect.PIPE)
                .start()
                .inputStream.bufferedReader()
                .readText().trim()

            if (cliPath.isEmpty()) {
                throw GradleException("`openapi-generator-cli` not found in system. Please install it first: https://github.com/OpenAPITools/openapi-generator-cli?tab=readme-ov-file#installation")
            }

            val startTime = System.currentTimeMillis()

            try {
                command = "$cliPath generate -i $from -o $to $generator $mappings $additional"
                super.exec()

                val generationTime = System.currentTimeMillis() - startTime
                val cleanupStartTime = System.currentTimeMillis()

                val cleanupStats = cleanUpAutogeneratedFiles(to)
                val cleanupTime = System.currentTimeMillis() - cleanupStartTime
                val totalTime = System.currentTimeMillis() - startTime

                printSuccessFooter(generationTime, cleanupTime, totalTime, cleanupStats)

            } catch (e: Exception) {
                val totalTime = System.currentTimeMillis() - startTime
                printErrorFooter(e, totalTime)
                throw e
            }

        } else if (from.parentFile.exists() && project.name != "gateway") {
            printNotFoundError()
        }
    }

    private fun cleanUpAutogeneratedFiles(to: File): CleanupStats {
        println("ğŸ§¹ Starting cleanup of generated files...")
        val stats = CleanupStats()

        val fromSubprojectRoot = "${project.projectDir}"

        // Remove known unwanted directories and files
        listOf(
            File("$fromSubprojectRoot/Users"),
            File("$to/.openapi-generator")
        ).forEach { file ->
            if (file.exists()) {
                val size = file.calculateSize()
                if (file.deleteRecursively()) {
                    stats.filesRemoved++
                    stats.bytesFreed += size
                    println("ğŸ—‘ï¸  Removed: ${file.toString().substringAfter(project.rootDir.toString())}")
                }
            }
        }

        // Remove openapi tools config files
        "openapitools.json".run {
            listOf(
                File("$fromSubprojectRoot/$this"),
                File("${project.rootDir}/$this")
            ).forEach { file ->
                if (file.exists() && file.delete()) {
                    stats.filesRemoved++
                    stats.bytesFreed += file.length()
                    println("ğŸ—‘ï¸  Removed: ${file.toString().substringAfter(project.rootDir.toString())}")
                }
            }
        }

        if (deleteNotTSFiles) {
            // First pass: delete non-TS files
            to.walk().forEach { file ->
                if (file.isFile && !file.name.endsWith(".ts")) {
                    val size = file.length()
                    if (file.delete()) {
                        stats.filesRemoved++
                        stats.bytesFreed += size
                        println("ğŸ—‘ï¸  Removed file: ${file.toString().substringAfter(project.rootDir.toString())}")
                    }
                }
            }

            // Second pass: delete empty directories
            to.walk(FileWalkDirection.BOTTOM_UP).forEach { dir ->
                if (dir.isDirectory && dir != to) {
                    val isEmpty = dir.listFiles()?.isEmpty() == true
                    if (isEmpty && dir.delete()) {
                        stats.dirsRemoved++
                        println("ğŸ—‘ï¸  Removed empty directory: ${dir.toString().substringAfter(project.rootDir.toString())}")
                    }
                }
            }
        }

        println("âœ¨ Cleanup completed: ${stats.filesRemoved} files, ${stats.dirsRemoved} directories removed")
        return stats
    }

    private fun printStartHeader() {
        println()
        println("â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”")
        println("â”‚            ğŸ”§ TYPESCRIPT API CODE GENERATION                     â”‚")
        println("â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜")
        println("ğŸ“‚ Project: ${project.name}")
        println("ğŸ“„ Schema: $fromFilename")
        println("ğŸ¯ Target: $generatorName")
        println("ğŸ“¥ Source: ${project.name}$fromLocation/$fromFilename")
        println("ğŸ“¤ Output: $toFolder")
        println("ğŸ”§ Models: ${if (separateModels) "$modelPackage package" else "Inline models"}")
        println("ğŸ® APIs: $apiPackage")
        println()
        println("ğŸ§¹ Cleanup: ${if (deleteNotTSFiles) "Enabled" else "Disabled"}")
        println("ğŸ”„ Map Set->Array: ${if (mapSetsToArrays) "Yes" else "No"}")
        println()
        println("ğŸš€ Starting code generation...")
        println()
    }

    private fun printSuccessFooter(generationTime: Long, cleanupTime: Long, totalTime: Long, cleanupStats: CleanupStats) {
        println()
        println("â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”")
        println("â”‚                   âœ¨ GENERATION COMPLETED                        â”‚")
        println("â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜")
        println("â±ï¸ Generation Time: ${formatDuration(generationTime)}")
        println("ğŸ§¹ Cleanup Time: ${formatDuration(cleanupTime)}")
        println("ğŸ¯ Total Time: ${formatDuration(totalTime)}")
        println()
        println("ğŸ“ Files Removed: ${cleanupStats.filesRemoved}")
        println("ğŸ—‚ï¸  Dirs Removed: ${cleanupStats.dirsRemoved}")
        println("ğŸ“¦ Size Freed: ${formatBytes(cleanupStats.bytesFreed)}")
        println()
        println("ğŸ‰ TypeScript API client ready to use!")
    }

    private fun printErrorFooter(error: Exception, totalTime: Long) {
        println()
        println("â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”")
        println("â”‚                     âŒ GENERATION FAILED                         â”‚")
        println("â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜")
        println("â±ï¸ Duration: ${formatDuration(totalTime)}")
        println("ğŸ’¥ Error: ${error.message ?: "Unknown error"}")
        println()
    }

    private fun printNotFoundError() {
        println()
        println("â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”")
        println("â”‚                   âš ï¸  SCHEMA FILE NOT FOUND                     â”‚")
        println("â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜")
        println("ğŸ” Looking for: $fromFilename")
        println("ğŸ“ Expected at: ${project.name}$fromLocation")
        println()
        println("ğŸ’¡ Try running: gradle generateOpenApiDocs")
        println()
    }

    private fun formatDuration(millis: Long): String {
        return when {
            millis < 1000 -> "${millis}ms"
            millis < 60000 -> "${String.format("%.1f", millis / 1000.0)}s"
            else -> "${millis / 60000}m ${(millis % 60000) / 1000}s"
        }
    }

    private fun formatBytes(bytes: Long): String {
        return when {
            bytes < 1024 -> "${bytes}B"
            bytes < 1024 * 1024 -> "${String.format("%.1f", bytes / 1024.0)}KB"
            else -> "${String.format("%.1f", bytes / (1024.0 * 1024.0))}MB"
        }
    }

    private fun File.calculateSize(): Long {
        return if (isDirectory) {
            walkTopDown().filter { it.isFile }.map { it.length() }.sum()
        } else {
            length()
        }
    }

    private data class CleanupStats(
        var filesRemoved: Int = 0,
        var dirsRemoved: Int = 0,
        var bytesFreed: Long = 0
    )
}

fun Project.registerOpenApiAxiosApiTsTask() = tasks.register<OpenApiAxiosTypeScriptCodeGenerator>("apiGen") {
    description = "Generate TypeScript frontend with Axios generator"
    outputs.upToDateWhen { false }

    tasks.findByName("generateOpenApiDocs")?.let{
        mustRunAfter(it)
        dependsOn(it)
//        inputs.file(File("${project.projectDir}$fromLocation/$fromFilename"))
//        outputs.dir(File("${project.rootDir}/$toFolder"))
    }
}

val Project.apiGen: TaskProvider<OpenApiAxiosTypeScriptCodeGenerator>
    get() = tasks.named<OpenApiAxiosTypeScriptCodeGenerator>("apiGen")
