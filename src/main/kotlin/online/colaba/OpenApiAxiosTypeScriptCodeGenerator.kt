package online.colaba

import org.gradle.api.GradleException
import org.gradle.api.Project
import org.gradle.api.tasks.Input
import org.gradle.api.tasks.TaskAction
import org.gradle.api.tasks.TaskProvider
import org.gradle.kotlin.dsl.named
import org.gradle.kotlin.dsl.register
import java.io.File

open class OpenApiAxiosTypeScriptCodeGenerator : Executor() {
    init {
        group = "$dockerPrefix-${project.name}"
        description = "Generating [ TypeScript Axios API] OPEN API."
    }

    @get:Input var fromLocation : String = "/src/test/resources"
    @get:Input var fromFilename : String = "openapi.json"

    @get:Input var toFolder   : String = "/frontend/api/${project.name}"
    @get:Input var toFilename : String = "schema-${project.name}"

    @get:Input var generatorName : String  = "typescript-axios"

    @get:Input var addInfo : Set<String> = setOf(
        "swaggerAnnotations=true",
        "supportsES6=true",
        "serviceImplementation=true",
        "nullSafeAdditionalProps=true",
        "enumPropertyNaming=UPPERCASE",
        "typescriptThreePlus=true",
        "legacyDiscriminatorBehavior=false",
    )
    @get:Input var deleteNotTSFiles : Boolean = true

    @get:Input var separateModels : Boolean = true
    @get:Input var apiPackage     : String  = "controllers"
    @get:Input var modelPackage   : String  = "models"

    @get:Input var enablePostProcessFile : Boolean = false


    @TaskAction override fun exec() {
        var arguments = addInfo.joinToString(",")
        if (separateModels) arguments += ",withSeparateModelsAndApi=true,modelPackage=$modelPackage,apiPackage=$apiPackage"
        if (enablePostProcessFile) arguments += ",enablePostProcessFile=true"

        val from = File("${project.projectDir}$fromLocation/$fromFilename")
        val to = File("${project.rootDir}/$toFolder")

        if (from.exists()) {
            printStartHeader()

            val generator = "--generator-name $generatorName"
            val additional = "--additional-properties=$arguments"

            val cliPath: String = ProcessBuilder("/bin/bash", "-l", "-c", "which openapi-generator-cli")
                .redirectOutput(ProcessBuilder.Redirect.PIPE)
                .start()
                .inputStream.bufferedReader()
                .readText().trim()

            if (cliPath.isEmpty()) {
                throw GradleException("`openapi-generator-cli` not found in system. Please install it first: https://github.com/OpenAPITools/openapi-generator-cli?tab=readme-ov-file#installation")
            }

            val startTime = System.currentTimeMillis()

            try {
                command = "$cliPath generate -i $from -o $to $generator $additional"
                super.exec()

                val generationTime = System.currentTimeMillis() - startTime
                val cleanupStartTime = System.currentTimeMillis()

                val cleanupStats = cleanUpAutogeneratedFiles(to)
                val cleanupTime = System.currentTimeMillis() - cleanupStartTime
                val totalTime = System.currentTimeMillis() - startTime

                printSuccessFooter(generationTime, cleanupTime, totalTime, cleanupStats)

            } catch (e: Exception) {
                val totalTime = System.currentTimeMillis() - startTime
                printErrorFooter(e, totalTime)
                throw e
            }

        } else if (from.parentFile.exists() && project.name != "gateway") {
            printNotFoundError()
        }
    }

    private fun cleanUpAutogeneratedFiles(to: File): CleanupStats {
        println("ğŸ§¹ Starting cleanup of generated files...")
        val stats = CleanupStats()

        val fromSubprojectRoot = "${project.projectDir}"

        // Remove known unwanted directories and files
        listOf(
            File("$fromSubprojectRoot/Users"),
            File("$to/.openapi-generator")
        ).forEach { file ->
            if (file.exists()) {
                val size = file.calculateSize()
                if (file.deleteRecursively()) {
                    stats.filesRemoved++
                    stats.bytesFreed += size
                    println("ğŸ—‘ï¸  Removed: ${file.toString().substringAfter(project.rootDir.toString())}")
                }
            }
        }

        // Remove openapi tools config files
        "openapitools.json".run {
            listOf(
                File("$fromSubprojectRoot/$this"),
                File("${project.rootDir}/$this")
            ).forEach { file ->
                if (file.exists() && file.delete()) {
                    stats.filesRemoved++
                    stats.bytesFreed += file.length()
                    println("ğŸ—‘ï¸  Removed: ${file.toString().substringAfter(project.rootDir.toString())}")
                }
            }
        }

        if (deleteNotTSFiles) {
            // First pass: delete non-TS files
            to.walk().forEach { file ->
                if (file.isFile && !file.name.endsWith(".ts")) {
                    val size = file.length()
                    if (file.delete()) {
                        stats.filesRemoved++
                        stats.bytesFreed += size
                        println("ğŸ—‘ï¸  Removed file: ${file.toString().substringAfter(project.rootDir.toString())}")
                    }
                }
            }

            // Second pass: delete empty directories
            to.walk(FileWalkDirection.BOTTOM_UP).forEach { dir ->
                if (dir.isDirectory && dir != to) {
                    val isEmpty = dir.listFiles()?.isEmpty() == true
                    if (isEmpty && dir.delete()) {
                        stats.dirsRemoved++
                        println("ğŸ—‘ï¸  Removed empty directory: ${dir.toString().substringAfter(project.rootDir.toString())}")
                    }
                }
            }
        }

        println("âœ¨ Cleanup completed: ${stats.filesRemoved} files, ${stats.dirsRemoved} directories removed")
        return stats
    }

    private fun printStartHeader() {
        println()
        println("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
        println("â•‘               ğŸ”§ TYPESCRIPT API CODE GENERATION                â•‘")
        println("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£")
        println("â•‘                                                                â•‘")
        println("â•‘  ğŸ“‚ Project:     ${project.name.padEnd(45)} â•‘")
        println("â•‘  ğŸ“„ Schema:      ${fromFilename.padEnd(45)} â•‘")
        println("â•‘  ğŸ¯ Target:      ${generatorName.padEnd(45)} â•‘")
        println("â•‘                                                                â•‘")
        println("â•‘  ğŸ“¥ Source:      ${("${project.name}$fromLocation/$fromFilename").take(43).padEnd(43)} â•‘")
        println("â•‘  ğŸ“¤ Output:      ${toFolder.take(43).padEnd(43)} â•‘")
        println("â•‘                                                                â•‘")
        println("â•‘  ğŸ”§ Models:      ${(if (separateModels) "$modelPackage package" else "Inline models").padEnd(43)} â•‘")
        println("â•‘  ğŸ® APIs:        ${apiPackage.padEnd(43)} â•‘")
        println("â•‘  ğŸ§¹ Cleanup:     ${(if (deleteNotTSFiles) "Enabled" else "Disabled").padEnd(43)} â•‘")
        println("â•‘                                                                â•‘")
        println("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
        println()
        println("ğŸš€ Starting code generation...")
        println()
    }

    private fun printSuccessFooter(generationTime: Long, cleanupTime: Long, totalTime: Long, cleanupStats: CleanupStats) {
        println()
        println("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
        println("â•‘                    âœ¨ GENERATION COMPLETED                      â•‘")
        println("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£")
        println("â•‘                                                                â•‘")
        println("â•‘  â±ï¸  Generation Time: ${formatDuration(generationTime).padEnd(36)} â•‘")
        println("â•‘  ğŸ§¹ Cleanup Time:    ${formatDuration(cleanupTime).padEnd(37)} â•‘")
        println("â•‘  ğŸ¯ Total Time:      ${formatDuration(totalTime).padEnd(37)} â•‘")
        println("â•‘                                                                â•‘")
        println("â•‘  ğŸ“ Files Removed:   ${cleanupStats.filesRemoved.toString().padEnd(37)} â•‘")
        println("â•‘  ğŸ—‚ï¸  Dirs Removed:    ${cleanupStats.dirsRemoved.toString().padEnd(36)} â•‘")
        println("â•‘  ğŸ“¦ Size Freed:      ${formatBytes(cleanupStats.bytesFreed).padEnd(37)} â•‘")
        println("â•‘                                                                â•‘")
        println("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
        println()
        println("ğŸ‰ TypeScript API client ready to use!")
    }

    private fun printErrorFooter(error: Exception, totalTime: Long) {
        println()
        println("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
        println("â•‘                      âŒ GENERATION FAILED                       â•‘")
        println("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£")
        println("â•‘                                                                â•‘")
        println("â•‘  â±ï¸  Duration: ${formatDuration(totalTime).padEnd(44)} â•‘")
        println("â•‘  ğŸ’¥ Error:    ${(error.message ?: "Unknown error").take(45).padEnd(45)} â•‘")
        println("â•‘                                                                â•‘")
        println("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
        println()
    }

    private fun printNotFoundError() {
        println()
        println("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
        println("â•‘                    âš ï¸  SCHEMA FILE NOT FOUND                   â•‘")
        println("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£")
        println("â•‘                                                                â•‘")
        println("â•‘  ğŸ” Looking for: ${fromFilename.padEnd(43)} â•‘")
        println("â•‘  ğŸ“ Expected at: ${("${project.name}$fromLocation").take(43).padEnd(43)} â•‘")
        println("â•‘                                                                â•‘")
        println("â•‘  ğŸ’¡ Try running: gradle generateOpenApiDocs                    â•‘")
        println("â•‘                                                                â•‘")
        println("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
        println()
    }

    private fun formatDuration(millis: Long): String {
        return when {
            millis < 1000 -> "${millis}ms"
            millis < 60000 -> "${String.format("%.1f", millis / 1000.0)}s"
            else -> "${millis / 60000}m ${(millis % 60000) / 1000}s"
        }
    }

    private fun formatBytes(bytes: Long): String {
        return when {
            bytes < 1024 -> "${bytes}B"
            bytes < 1024 * 1024 -> "${String.format("%.1f", bytes / 1024.0)}KB"
            else -> "${String.format("%.1f", bytes / (1024.0 * 1024.0))}MB"
        }
    }

    private fun File.calculateSize(): Long {
        return if (isDirectory) {
            walkTopDown().filter { it.isFile }.map { it.length() }.sum()
        } else {
            length()
        }
    }

    private data class CleanupStats(
        var filesRemoved: Int = 0,
        var dirsRemoved: Int = 0,
        var bytesFreed: Long = 0
    )
}

fun Project.registerOpenApiAxiosApiTsTask() = tasks.register<OpenApiAxiosTypeScriptCodeGenerator>("apiGen") {
    description = "Generate TypeScript frontend with Axios generator"
    outputs.upToDateWhen { false }

    tasks.findByName("generateOpenApiDocs")?.let{
        mustRunAfter(it)
        dependsOn(it)
//        inputs.file(File("${project.projectDir}$fromLocation/$fromFilename"))
//        outputs.dir(File("${project.rootDir}/$toFolder"))
    }
}

private fun formatTableCell(label: String, value: String): String {
    // Ğ’ÑĞµĞ³Ğ¾ 64 ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ° Ğ¼ĞµĞ¶Ğ´Ñƒ â•‘, Ğ¼Ğ¸Ğ½ÑƒÑ 3 Ğ´Ğ»Ñ Ğ½Ğ°Ñ‡Ğ°Ğ»ÑŒĞ½Ñ‹Ñ… Ğ¿Ñ€Ğ¾Ğ±ĞµĞ»Ğ¾Ğ² = 61 ÑĞ¸Ğ¼Ğ²Ğ¾Ğ» Ğ´Ğ»Ñ ĞºĞ¾Ğ½Ñ‚ĞµĞ½Ñ‚Ğ°
    val totalWidth = 61
    val labelWithoutEmoji = label.replace(Regex("[\uD83C-\uDBFF\uDC00-\uDFFF]+"), "X") // Ğ·Ğ°Ğ¼ĞµĞ½ÑĞµĞ¼ emoji Ğ½Ğ° X Ğ´Ğ»Ñ Ñ€Ğ°ÑÑ‡ĞµÑ‚Ğ°
    val usedWidth = labelWithoutEmoji.length + 1 + value.length // +1 Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¾Ğ±ĞµĞ»Ğ°
    val paddingNeeded = maxOf(0, totalWidth - usedWidth)

    return "$label $value${" ".repeat(paddingNeeded)}"
}

val Project.apiGen: TaskProvider<OpenApiAxiosTypeScriptCodeGenerator>
    get() = tasks.named<OpenApiAxiosTypeScriptCodeGenerator>("apiGen")
